<!DOCTYPE html>
<html lang="en">
<head>
  <title>Alok Menghrajani's stuff | ajsone: Abusing JSON Esolang</title>
  <meta property="fb:admins" content="536181839"/>
  <meta name="author" content="Alok Menghrajani"/>
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <link href="../bootstrap-responsive.min.css" rel="stylesheet">
  <link href="../bootstrap-2.3.1.min.css" rel="stylesheet"/>
  <link href="../alok.css" rel="stylesheet"/>
  <script type="text/javascript" src="../jquery-1.7.1.min.js"></script>
  <link href="../prettify/prettify.css" type="text/css" rel="stylesheet"/>
  <script type="text/javascript" src="../prettify/prettify.js"></script>
  <script type="text/javascript" src="ajsone.js"></script>
  <script type="text/javascript" src="ajsone_utils.js"></script>
</head>
<body onload="prettyPrint()">
  <div class="container-narrow">
    <div class="menu visible-desktop">
      <div class="profile">
        <p class="pull-right"><a href="../">&larr; Back to home</a></p>
      </div>
    </div>

    <div class="jumbotron">
      <h1>openssl wtf</h1>
      <div class="lead">
        <p>
          A minor WTF in openssl, where mixing encryption &amp; decryption functions
          does not result in an error. This can lead to subtle security bugs if the
          code is poorly written.
        </p>
        <p>
          A sane library should fail at the EVP_DecryptUpdate on line 123. Running
          this code (openssl 1.0.1) however results in:
        </p>
        <pre>
Encrypting:
  assertion ok: EVP_EncryptInit_ex
  assertion ok: EVP_EncryptUpdate
  assertion ok: EVP_EncryptFinal_ex
  assertion ok: check ct1 len
cipher text: eb87ad64ea2696370c99e6e7

Decrypting:
  assertion ok: EVP_DecryptInit_ex
  assertion ok: EVP_DecryptUpdate
  assertion ok: EVP_DecryptFinal_ex
  assertion ok: check pt2 len
  assertion ok: pt2 == pt1
plain text: hello world

Decrypting a subset, with EVP_EncryptInit_ex
  assertion ok: EVP_EncryptInit_ex
  assertion ok: EVP_DecryptUpdate
  assertion ok: EVP_DecryptFinal_ex
plain text: hello worl

Decrypting a subset, with EVP_DecryptInit_ex
  assertion ok: EVP_DecryptInit_ex
  assertion ok: EVP_DecryptUpdate
  ASSERTION FAILURE: EVP_DecryptFinal_ex
plain text: hello worl
</pre>
      </div>
    </div>

<p>openssl_wtf.c:</p>
<pre class="prettyprint linenums lang-c">
/**
 * openssl's EVP library does not prevent you from mixing
 * encryption &amp; decryption functions on a given ctx. This
 * can lead to subtle bugs if the code is poorly written.
 * Data will get decrypted but not authenticated!
 *
 * Compile and run with:
 * gcc -o openssl_wtf openssl_wtf.c
 *            -L/usr/lib/x86_64-linux-gnu/ -lssl -lcrypto
 * ./openssl_wtf
 */
#include &lt;stdio.h&gt;
#include &lt;strings.h&gt;
#include &lt;openssl/bio.h&gt;
#include &lt;openssl/evp.h&gt;
#include &lt;openssl/rand.h&gt;

void assert(int exp, char *msg) {
  if (!exp) {
    printf("  ASSERTION FAILURE: %s\n", msg);
  } else {
    printf("  assertion ok: %s\n", msg);
  }
}

int main(int argc, char **argv) {
  unsigned char *key = (unsigned char *)"blah";
 
  unsigned char iv[12] = { 0x00 };
  unsigned char tag[16] = { 0x00 };
  unsigned char pt1[] =
    {'h', 'e', 'l', 'l', 'o', ' ', 'w', 'o', 'r', 'l', 'd', 0};
  unsigned char ct1[sizeof(pt1)];
  unsigned char ct2[sizeof(pt1) - 2];
  unsigned char pt2[sizeof(pt1)];
 
  EVP_CIPHER_CTX ctx;
  int ct_offset, pt2_offset, t, r;
 
  EVP_CIPHER_CTX_init(&amp;ctx);
 
  /* Initialize IV, don't use pseudo_bytes in real code */
  RAND_pseudo_bytes(iv, sizeof(iv));

  /* Encrypt the plain text */
  printf("Encrypting:\n");
  bzero(ct1, sizeof(ct1));
  r = EVP_EncryptInit_ex(&amp;ctx, EVP_aes_256_gcm(), NULL, key, iv);
  assert(r == 1, "EVP_EncryptInit_ex");
 
  ct_offset = 0;
 
  r = EVP_EncryptUpdate(&amp;ctx, ct1 + ct_offset, &amp;t, pt1, sizeof(pt1));
  ct_offset += t;
  assert(r == 1, "EVP_EncryptUpdate");
 
  r = EVP_EncryptFinal_ex(&amp;ctx, ct1 + ct_offset, &amp;t);
  ct_offset += t;
  assert(r == 1, "EVP_EncryptFinal_ex");
 
  assert(ct_offset == sizeof(ct1), "check ct1 len");
 
  /* Save tag */
  EVP_CIPHER_CTX_ctrl(&amp;ctx, EVP_CTRL_GCM_GET_TAG, sizeof(tag), tag);

  /* Clean up */
  EVP_CIPHER_CTX_cleanup(&amp;ctx);
 
  printf("cipher text: ");
  for (t=0; t&lt;sizeof(ct1); t++) {
    printf("%02x", ct1[t]);
  }
  printf("\n\n");
 
  /* Decrypt the cipher text */
  printf("Decrypting:\n");
  bzero(pt2, sizeof(pt1));
  EVP_CIPHER_CTX_init(&amp;ctx);
 
  r = EVP_DecryptInit_ex(&amp;ctx, EVP_aes_256_gcm(), NULL, key, iv);
  assert(r == 1, "EVP_DecryptInit_ex");
 
  EVP_CIPHER_CTX_ctrl(&amp;ctx, EVP_CTRL_GCM_SET_TAG, sizeof(tag), tag);
 
  pt2_offset = 0;
 
  r = EVP_DecryptUpdate(&amp;ctx, pt2 + pt2_offset, &amp;t, ct1, sizeof(ct1));
  pt2_offset += t;
  assert(r == 1, "EVP_DecryptUpdate");
 
  r = EVP_DecryptFinal_ex(&amp;ctx, pt2 + pt2_offset, &amp;t);
  pt2_offset += t;
  assert(r == 1, "EVP_DecryptFinal_ex");
 
  assert(pt2_offset == sizeof(pt1), "check pt2 len");
 
  r = 1;
  for (t=0; t&lt;sizeof(pt1); t++) {
    r = r &amp;&amp; (pt1[t] == pt2[t]);
  }
  assert(r == 1, "pt2 == pt1");
  printf("plain text: %s\n", pt2);  
  EVP_CIPHER_CTX_cleanup(&amp;ctx);
  printf("\n"); 
 
  /* Truncate the cipher text */
  for (t=0; t&lt;sizeof(ct2); t++) {
    ct2[t] = ct1[t];
  }

  /* Decrypt a subset */
  printf("Decrypting a subset, with EVP_EncryptInit_ex\n");
  bzero(pt2, sizeof(pt2));
  EVP_CIPHER_CTX_init(&amp;ctx);
 
  r = EVP_EncryptInit_ex(&amp;ctx, EVP_aes_256_gcm(), NULL, key, iv);
  assert(r == 1, "EVP_EncryptInit_ex");
 
  EVP_CIPHER_CTX_ctrl(&amp;ctx, EVP_CTRL_GCM_SET_TAG, sizeof(tag), tag);
 
  pt2_offset = 0;
 
  r = EVP_DecryptUpdate(&amp;ctx, pt2 + pt2_offset, &amp;t, ct2, sizeof(ct2));
  pt2_offset += t;
  assert(r == 1, "EVP_DecryptUpdate");
 
  r = EVP_DecryptFinal_ex(&amp;ctx, pt2 + pt2_offset, &amp;t);
  pt2_offset += t; 
  assert(r == 1, "EVP_DecryptFinal_ex");
  printf("plain text: %s\n", pt2);
  EVP_CIPHER_CTX_cleanup(&amp;ctx);
  printf("\n");
 
 
  /* Decrypt a subset, correctly this time */
  printf("Decrypting a subset, with EVP_DecryptInit_ex\n");
  bzero(pt2, sizeof(pt2));
  EVP_CIPHER_CTX_init(&amp;ctx);
 
  r = EVP_DecryptInit_ex(&amp;ctx, EVP_aes_256_gcm(), NULL, key, iv);
  assert(r == 1, "EVP_DecryptInit_ex");
 
  EVP_CIPHER_CTX_ctrl(&amp;ctx, EVP_CTRL_GCM_SET_TAG, sizeof(tag), tag);
 
  pt2_offset = 0;
 
  r = EVP_DecryptUpdate(&amp;ctx, pt2 + pt2_offset, &amp;t, ct2, sizeof(ct2));
  pt2_offset += t;
  assert(r == 1, "EVP_DecryptUpdate");
 
  r = EVP_DecryptFinal_ex(&amp;ctx, pt2 + pt2_offset, &amp;t);
  pt2_offset += t;
  assert(r == 1, "EVP_DecryptFinal_ex");
  printf("plain text: %s\n", pt2); 
  EVP_CIPHER_CTX_cleanup(&amp;ctx);
}
</pre>

    <footer class="footer">
      <div style="float: left" class="fb-like" data-send="false" data-width="450" data-show-faces="false"></div>
      <p class="pull-right visible-desktop">
        <a href="https://github.com/alokmenghrajani/alokmenghrajani.github.com/issues/new">contact me</a>
        <span class="vbar"></span>
        <a href="#">back to top &uarr;</a>
      </p>
    </footer>
  </div>

<script>
  (function(i,s,o,g,r,a,m){i['GoogleAnalyticsObject']=r;i[r]=i[r]||function(){
  (i[r].q=i[r].q||[]).push(arguments)},i[r].l=1*new Date();a=s.createElement(o),
  m=s.getElementsByTagName(o)[0];a.async=1;a.src=g;m.parentNode.insertBefore(a,m)
  })(window,document,'script','//www.google-analytics.com/analytics.js','ga');

  ga('create', 'UA-2373559-12', 'quaxio.com');
  ga('send', 'pageview');
</script>

<div id="fb-root"></div>
<script>(function(d, s, id) {
  var js, fjs = d.getElementsByTagName(s)[0];
  if (d.getElementById(id)) return;
  js = d.createElement(s); js.id = id;
  js.src = "//connect.facebook.net/en_US/all.js#xfbml=1&appId=202717489767277";
  fjs.parentNode.insertBefore(js, fjs);
}(document, 'script', 'facebook-jssdk'));</script>

  </body>
</html>

