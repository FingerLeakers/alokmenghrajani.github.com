<html>
<head></head>
<body>
<p>A list of PHP weirdness...</p>

<h2>operator precedence</h2>
<p>PHP's operator's don't always follow the C standard. This can lead to subtle bugs, so the
recommendation is to use and abuse () in expressions.</p>

<h3>PHP code</h3>
<pre>
&lt;?php

echo 1 ? 2 : 3 ? 4 : 5;
</pre>
<h3>output</h3>
<pre>
4
</pre>
<h3>C code</h3>
<pre>
#include <stdio.h>

int main() {
  printf("f=%d\n", 1 ? 2 : 3 ? 4 : 5);
  return 0;
}
</pre>
<h3>output</h3>
<pre>
2
</pre>

<hr/>

<h2>Calling instance methods in static context</h2>
<h3>PHP code</h3>
<pre>
&lt;?php

class A {
  public function printName() {
   echo 'I am:', get_class($this), "\n";
  }

  public function foo() {
    return A::printName();
  }
}

class B {
  public function foo() {
    A::printName();
  }
}

$a = new A();
$a->foo();

$b = new B();
$b->foo();
</pre>

<h3>output</h3>
<pre>
I am: A
I am: B
</pre>

<hr/>

<h2>Can't call future constructor</h2>
<h3>PHP code</h3>
<pre>
&lt;?php

class A {
}

class B extends A {
  public function __construct() {
    // make sure parent constructor gets called if someone adds one
    parent::__construct();
  }
}

new B();
</pre>

<h3>output</h3>
<pre>
Fatal PHP Fatal error: Can not call constructor in...
</pre>

<hr/>

<h2>Redefine private methods</h2>
<h3>PHP code</h3>
<pre>
&lt;?php

class A {
  private function foo() {
    return 'foo in A';
  }

  public function bar() {
    echo $this->foo(), "\n";
  }
}

class B extends A {
  private function foo() {
    return 'foo in B';
  }

  public function bar2() {
    echo $this->foo(), "\n";
  }
}

$b = new B();
$b->bar2();
$b->bar();
</pre>

<h3>output</h3>
<pre>
foo in B
foo in A
</pre>

<hr/>

<h2>__construct is just another method</h2>
<h3>PHP code</h3>
<pre>
&lt;?php

class A {
  public $v;

  public function __construct($v) {
    $this->v = $v;
  }
}

$a = new A(42);
$b = range(0, 9);
for ($i=0; $i<10; $i++) {
  $b[$i] = $a->__construct($i);
  echo 'memory:', memory_get_usage(), "\n";
}
</pre>

<h3>output</h3>
<pre>
memory: 629952
memory: 629952
memory: 629952
memory: 629952
memory: 629952
memory: 629952
memory: 629952
memory: 629952
memory: 629952
memory: 629952
</pre>

<hr/>

<h2>curl_multi_exec</h2>
<p>curl_multi_exec does not affect curl_errno(), but it does affect
curl_error().</p>
<pre>
&lt;?php

$c = curl_init('http://www.google.com:443/');
curl_setopt($c, CURLOPT_RETURNTRANSFER, true);
$mh = curl_multi_init();
curl_multi_add_handle($mh,$c);
$active = null;
do {
  $mrc = curl_multi_exec($mh, $active);
} while ($mrc == CURLM_CALL_MULTI_PERFORM || $active);

$r = curl_multi_info_read($mh);
echo $r['result'], "\n";
echo curl_errno($c), "\n";
echo curl_error($c), "\n";
</pre>

<h3>output</h3>
<pre>
52
0
Empty reply from server
</pre>

<hr/>

<h2>don't trust ==</h2>
Credits: erling
<pre>
&lt;?php

echo (int)("  4"  == "    4"), "\n";
echo (int)("  4 " == "    4 "), "\n";
</pre>

<h3>output</h3>
<pre>
1
0
</pre>

<hr/>

<h2>Funny increments</h2>
In general, I have tried to avoid critizing php's API, however this one deserves to be listed here:
<pre>
&lt;?php

$x = "x";
$x++; $x++; $x++;
echo $x, "\n";
$x--; $x--; $x--;
echo $x, "\n";
</pre>

<h3>output</h3>
<pre>
aa
aa
</pre>

<hr/>

<h2>don't trust get_class()</h2>
credits: jfrank
<pre>
&lt;?php

class A { }

class Foo {
  public static function bar($x) {
    echo get_class($x), "\n";
  }
}

Foo::bar(new A());
Foo::bar(null);
</pre>

<h3>output</h3>
<pre>
A
Foo
</pre>

</body>
</html>
